\documentclass{article}

\usepackage{listings}
\usepackage{xcolor}
\usepackage{amsmath}
\usepackage[default]{sourcecodepro}
\usepackage[default]{sourcesanspro}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[margin=0.8in, bmargin=0.7in]{geometry}
\usepackage{titlesec}
\usepackage{fancyhdr}
\usepackage{graphicx}

\renewcommand\headrulewidth{0pt}

\fancypagestyle{plain}{
\fancyhead[L]{\color{black!75} Lund University}
\fancyhead[C]{\color{black!75} Balloon Overflow}
\fancyhead[R]{\color{black!75} \thepage}
\fancyfoot[C]{}}
\pagestyle{plain}

\setlength\parindent{0pt}
\setlength{\parskip}{0.25em}
\titleformat{\subsection}{\bfseries}{\thesection}{1.2em}{}
\titleformat{\section}{\normalfont\Large\bfseries}{\thesection}{1em}{}[{\titlerule[0.8pt]}]
\titlespacing{\section}{0pt}{0.5em}{0.5em}
\titlespacing{\subsection}{0pt}{0pt}{0.2em}

\lstset{ 
  backgroundcolor=\color{white},
  basicstyle=\ttfamily\footnotesize,
  breakatwhitespace=false,
  breaklines=true,
  keepspaces=true,
  numbers=left,
  numbersep=5pt,
  tabsize=4,
  rulecolor=\color{black},
  numberstyle=\tiny\color{black!50},
  stringstyle=\color[rgb]{0.58,0,0.82},
  commentstyle=\itshape\color{green!30!black},
  keywordstyle=\bfseries\color[HTML]{016477},
  aboveskip=0.3 \baselineskip,
  belowskip=1.0 \baselineskip
}

\begin{document}

\begin{titlepage}
  \centering
  \topskip0pt
  \vspace*{\fill}
  \includegraphics[width=100pt]{balloon.jpg}\\
  \vspace{0.5cm}
  {\scshape\Huge Balloon Overflow Notebook \par}
  \vspace{1cm}
  {\LARGE\color{black!75} Lund University \par}
  \vspace*{\fill}
\end{titlepage}

\section*{Misc}

\subsection*{Template}
\lstinputlisting[language=C++]{code/common.hpp}

\subsection*{Optimization Pragma}
\begin{lstlisting}[language=C++]
#pragma GCC optimize("Ofast")
\end{lstlisting}

\subsection*{Compilation Script}
\lstinputlisting[language=bash]{scripts/compile.sh}

\subsection*{Run Script}
Usage: \lstinline{./run.sh path/to/sample/folder ./solution.bin}
\lstinputlisting[language=bash]{scripts/run.sh}

\section*{Geometry}

\subsection*{Geometry Template}
\lstinputlisting[language=python]{code/geometry/geometry.py}

\subsection*{Distance between point and line segment}
Returns the distance from the point p to the line segment starting at s and ending at e.
\lstinputlisting[language=python]{code/geometry/dist_ps.py}

\subsection*{Distance between point and line}
Returns the signed distance from the point p to the line passing through the points a and b.
\lstinputlisting[language=python]{code/geometry/dist_pl.py}

\subsection*{Check if point is on line segment}
\lstinputlisting[language=python]{code/geometry/on_segment.py}

\subsection*{Project point to line (or reflect)}
Projects the point p onto the line passing through a and b.\\
Set \lstinline{refl=True} to get reflection of point p across the line instead.
\lstinputlisting[language=python]{code/geometry/proj_pl.py}

\subsection*{Intersection between two lines}
If a unique intersection point of the lines going through \lstinline{s1,e1} and \lstinline{s2,e2} exists \lstinline{(1,point)} is returned.\\
If no intersection point exists \lstinline{(0,(0,0))} is returned and if infinitely many exist \lstinline{(-1,(0,0))} is returned.
\lstinputlisting[language=python]{code/geometry/intersect_ll.py}

\subsection*{Intersection between two line segments}
If a unique intersection is found, returns a list with only this point.
If the segments intersect in many points, returns a list of 2 elements containing the
start and end of the common line segment. If no intersection, returns an empty list
\lstinputlisting[language=python]{code/geometry/intersect_ss.py}

\subsection*{Point inside polygon}
Returns true if the point \lstinline{pt} lies within the polygon \lstinline{poly}.
If strict is true, returns false for points on the boundary.
\lstinputlisting[language=python]{code/geometry/point_in_polygon.py}

\pagebreak

\subsection*{Polygon area}
Returns twice the signed area of a polygon. Clockwise enumeration gives negative area.
\lstinputlisting[language=python]{code/geometry/polygon_area.py}

\subsection*{Intersection between two circles}
Computes the pair of points at which two circles intersect. Returns \lstinline{None} in case of no intersection.
\lstinputlisting[language=python]{code/geometry/intersect_cc.py}

\subsection*{Convex hull (python)}
Returns a list of points on the convex hull in counter-clockwise order.
Points on the edge of the hull between two other points are not considered part of the hull.
Time complexity: $\mathcal{O}(n \log n)$
\lstinputlisting[language=python]{code/geometry/convex_hull.py}

\subsection*{Convex hull (C++)}
\lstinputlisting[language=C++]{code/geometry/convex_hull.cpp}

\pagebreak

\section*{Data Structures}

\subsection*{Segment Tree}
\lstinputlisting[language=C++]{code/segtree.cpp}

\subsection*{Fenwick Tree}
\lstinputlisting[language=C++, aboveskip=0pt]{code/fenwick_tree.cpp}

\subsection*{Sparse Table}
\lstinputlisting[language=C++, aboveskip=0pt]{code/sparse_table.cpp}

\pagebreak

\subsection*{Lazy Segment Tree}
Segment tree with support for range updates. Use T = pair of value and index to get index from queries.\\
All ranges are \lstinline{(lo, hi]} (hi is not included).
\lstinline{fQuery} defines the function to be used for queries (currently min) and 
\lstinline{fUpdate} defines the function to be used for updates (currently addition).
\lstinputlisting[language=C++]{code/lazy_segtree.cpp}

\subsection*{Line Container}
Container where you can add lines of the form $kx + m$, and query maximum values at points $x$.
All operations are $\mathcal{O}(\log(n))$. For doubles, use \lstinline{inf = 1/.0} and \lstinline{div(a,b) = a/b}
\lstinputlisting[language=C++]{code/line_container.cpp}

\subsection*{Treap}
\lstinputlisting[language=C++]{code/treap.cpp}

\section*{Graph Algorithms}

\subsection*{Floyd Warshall}

Calculates all-pairs shortest path in a directed graph.
Input is a distance matrix $m$, where \lstinline{m[i][j]=inf} if $i$ and $j$ are not adjacent.
As output, \lstinline{m[i][j]} is set to the shortest distance between $i$ and $j$,
\lstinline{inf} if no path, or \lstinline{-inf} if the path goes through a negative-weight cycle.

Time complexity: $\mathcal{O}(N^3)$.

\lstinputlisting[language=C++]{code/floyd_warshall.cpp}


\subsection*{Bellman Ford}

Calculates shortest paths from $s$ in a graph that might have negative edge weights.
Unreachable nodes get \lstinline{dist = inf}; nodes reachable through negative-weight cycles get \lstinline{dist = -inf}.
Assumes $V^2 \max |w_i| < 2^{63}$. Time complexity: $\mathcal{O}(VE)$

\lstinputlisting[language=C++]{code/bellman_ford.cpp}

\pagebreak

\subsection*{2-SAT}

Calculates a valid assignment to boolean variables in a 2-SAT problem.
Negated variables are represented by bit-inversions (\lstinline{~x}).
Time complexity: $\mathcal{O}(N+E)$, where $N$ is the number of boolean variables, and $E$ is the number of clauses.

\lstinputlisting[language=C++]{code/2sat.cpp}

Usage example:
\begin{lstlisting}[language=C++]
TwoSat ts(number of boolean variables);
ts.either(0, ~3); // Var 0 is true or var 3 is false
ts.set_value(2); // Var 2 is true
ts.at_most_one({0,~1,2}); // <= 1 of vars 0, ~1 and 2 are true
ts.solve(); // Returns true iff it is solvable. ts.values holds the assigned values to the variables
\end{lstlisting}

\pagebreak

\subsection*{Strongly Connected Components}

Finds strongly connected components in a directed graph. If vertices $u, v$ belong to the same component, we can reach $u$ from $v$ and vice versa.
Time complexity: $\mathcal{O}(E + V)$

Usage: \lstinline|scc(graph, [&](vector<int>& v) { ... })}| visits all components
in reverse topological order. \texttt{comp[i]} holds the component
index of a node (a component only has edges to components with
lower index). ncomps will contain the number of components.

\lstinputlisting[language=C++]{code/scc.cpp}


\subsection*{Biconnected Components}

Finds all biconnected components in an undirected graph, and
runs a callback for the edges in each. In a biconnected component there
are at least two distinct paths between any two nodes. Note that a node can
be in several components. An edge which is not in a component is a bridge,
i.e., not part of any cycle. Time complexity: $\mathcal{O}(E + V)$

\lstinputlisting[language=C++]{code/biconnected_components.cpp}

Usage example for biconnected components:
\begin{lstlisting}[language=C++]
int eid = 0; ed.resize(N);
for each edge (a,b) {
    ed[a].emplace_back(b, eid);
    ed[b].emplace_back(a, eid++);
}
bicomps([&](const vi& edgelist) {...});
\end{lstlisting}


\subsection*{Maximum Flow (Dinic's Algorithm)}

Constructor takes number of nodes, call \lstinline{addEdge} to add edges and \lstinline{calc} to find maximum flow.
To obtain the actual flow, look at positive values of \lstinline{Edge::cap} only.

Time complexity: $\mathcal{O}(VE\log U)$ where $U = \max |\text{cap}|$.
$\mathcal{O}(\min(E^{1/2}, V^{2/3})E)$ if $U = 1$.\\
$\mathcal{O}(\sqrt{V}E)$ for bipartite matching.
\lstinputlisting[language=C++]{code/max_flow.cpp}

\subsection*{Minimum Cost Maximum Flow}

Calculates min-cost max-flow. \lstinline{cap[i][j]!=cap[j][i]} is allowed; double edges are not. To obtain the actual flow, look at positive values only. Time complexity: Approximately $\mathcal{O}(E^2)$.

If costs can be negative, call \lstinline{setpi} before \lstinline{maxflow}, but note that negative cost cycles are not supported.

\lstinputlisting[language=C++]{code/min_cost_max_flow.cpp}

\pagebreak

\subsection*{Minimum Cost Bipartite Matching}
Cost matrix must be square! L and R are outputs describing the matching. Negate costs for max cost. Time complexity: $\mathcal{O}(n^3)$
\lstinputlisting[language=C++]{code/min_cost_matching.cpp}

\pagebreak

\section*{Math}

\subsection*{Solve Linear System of Equations}
Solves $A x = b$. If there are multiple solutions, an arbitrary one is returned.
Returns rank, or $-1$ if no solutions. Time complexity: $\mathcal{O}(n^2 m)$
\lstinputlisting[language=C++]{code/solve_linear.cpp}


\subsection*{Extended Euclidean Algorithm (python)}
Finds the Greatest Common Divisor to the integers $a$ and $b$. Also finds two integers $x$ and $y$, such that $ax+by=\gcd(a,b)$.
Returns a tuple of $(\gcd(a, b), x, y)$. If $a$ and $b$ are coprime, then $x$ is the inverse of $a \pmod{b}$.
\lstinputlisting[language=python]{code/euclid.py}

\subsection*{Extended Euclidean Algorithm (C++)}
\lstinputlisting[language=C++]{code/euclid.cpp}

\pagebreak

\subsection*{Chinese Remainder Theorem (python)}
Finds the smallest number $x$ satisfying a system of congruences, each in the form $x \equiv r_i \pmod{m_i}$. All pairs of $m_i$ must be coprime.
\lstinline{eq} is a list of tuples describing the equations, the $i$:th of which should be $(r_i, m_i)$.
\lstinputlisting[language=python]{code/crt.py}

\subsection*{Chinese Remainder Theorem (C++)}
Similar to python version. Make sure that the product of all $m_i$ is less than $2^{62}$.
\lstinputlisting[language=python]{code/crt.cpp}

\subsection*{Polynomial Roots}

Finds the real roots of a polynomial. Time complexity: $\mathcal{O}(n^2 \log(1/\epsilon))$.

Usage (solves $x^2-3x+2 = 0$): \lstinline[language=C++]|poly_roots({{ 2, -3, 1 }},-1e9,1e9)|

\lstinputlisting[language=C++]{code/poly_roots.cpp}

\subsection*{Fast Fourier Transform}
\lstinline{fft(a)} computes $\hat f(k) = \sum_x a[x] \exp(2\pi i \cdot k x / N)$ for all $k$.\\
Useful for convolution: \lstinline{conv(a, b)=c}, where $c[x] = \sum a[i]b[x-i]$.

Rounding is safe if $(\sum a_i^2 + \sum b_i^2)\log_2{N} < 9\cdot10^{14}$
(in practice $10^{16}$; higher for random inputs).

Time complexity: $\mathcal{O}(N \log N)$ with $N = |A|+|B|$ (about $1s$ for $N=4 \cdot 10^6$)
\lstinputlisting[language=C++]{code/fft.cpp}

\section*{Polynomial Hash}
\lstinputlisting[language=C++]{code/poly_hash.cpp}

\end{document}
